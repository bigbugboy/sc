8231226-001、lambda函数

如下程序的打印结果是____。

```python
squares = []

for x in range(5):
    squares.append(lambda: x**2)

result = squares[2]()
print(result)
```

选项A：0

选项B：1

选项C：4

选项D：16       ✅

解析：在给定的代码中，通过 for 循环创建了一个包含 5 个 lambda 函数的列表 `squares`，每个 lambda 函数都计算 `x**2`。然而，这些 lambda 函数中的每一个都共享了同一个变量 `x`。当 `x` 的值在循环结束后为 4 时，所有的 lambda 函数都被创建并添加到了列表中。  

当我们尝试调用 `squares[2]()` 或 `squares[4]()` 时，lambda 函数内部的 `x` 实际上引用的是循环结束时的 `x` 值，也就是 4。因此，无论我们调用哪个 lambda 函数，它们都会返回 4 的平方，即 16。

这是因为 lambda 函数在被调用时才会执行，而不是在定义时就计算 `x` 的值。





---



8231226-002、lambda函数

如下程序的打印结果是____。

```python
squares = []

for x in range(5):
    squares.append(lambda n=x: n**2)

result = squares[2]()
print(result)
```

选项A：0

选项B：1

选项C：4   ✅

选项D：16 

解析：这里使用lambda函数时，有一个形参n, 并且在创建函数时提供了默认值x，因此在循环结束后，第1个lambda中的参数n的是实参值是0，第2个lambda中的参数n的是实参值是1，第3个lambda中的参数n的是实参值是2， 以此类推。因此    `squares[2]()`的结果是4



---



8231227-001、局部变量

下面程序的打印结果是什么

```python
x = 10

def foo():
    x = 20
    x += 1
    print(x, end=',')

foo()
print(x)

```

选项A：21,21

选项B：21,20

选项C：10,10

选项D：21,10    ✅

解析：在程序中存在全局变量和局部变量。全局变量在整个程序中可见，而局部变量只在特定的作用域内可见。在这个程序中，存在全局变量 `x` 和函数 `foo` 内的局部变量 `x`。首先定义了一个全局变量 `x` 并赋值为 10。然后定义了一个名为 `foo` 的函数，在函数内部又定义了一个与全局变量同名的局部变量 `x`，并赋值为 20。在函数内部，局部变量 `x` 的值增加 1，变为 21，并打印出来。然后，调用函数 `foo`，打印出局部变量 `x` 的值，结果是 21。最后，在全局作用域中打印全局变量 `x` 的值，结果是 10。因此，打印结果是 "21,10"。





---



8231227-002、局部变量

下面程序的打印结果是什么

```python
x = 10

def foo():
    print(x, end=',')
    x += 1

foo()
print(x)

```

选项A：10,11

选项B：11,11

选项C：11,10

选项D：报错UnboundLocalError ✅

解析：这是因为当对作用域中的变量进行赋值时，该变量将成为该作用域的局部变量，并覆盖全局作用域中命名的变量。 由于 foo 中的最后一条语句为 x 分配了一个新值，因此编译器将其识别为局部变量。 因此，当前面的 print(x) 尝试打印未初始化的局部变量时，会产生错误。



---

8231227-003、局部变量

下面程序的打印结果是什么

```python
x = 10

def foo():
    print(x)
    x = 1


foo()


```

选项A：10

选项B：1

选项C：None

选项D：报错UnboundLocalError ✅

解析：这是因为当对作用域中的变量进行赋值时，该变量将成为该作用域的局部变量，并覆盖全局作用域中命名的变量。 由于 foo 中的最后一条语句为 x 分配了一个新值，因此编译器将其识别为局部变量。 因此，当前面的 print(x) 尝试打印未初始化的局部变量时，会产生错误。



---

8231227-004、全局变量

下面程序的打印结果是什么

```python
x = 10


def foo():
    global x
    print(x, end=',')
    x += 1


foo()
print(x)


```

选项A：10 ,11   ✅

选项B：10, 10

选项C：11, 10

选项D：11, 11

解析：由于在函数内部使用了 `global` 生命 `x` 为全局变量，所以访问的x是全局变量，对x的修改在全局环境产生变化，因此foo函数执行结束后，x的值就变成了11,最终的打印结果是10,11
